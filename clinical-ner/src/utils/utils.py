'''
__author__ = "Georges Nassopoulos"
__copyright__ = None
__version__ = "1.0.0"
__email__ = "georges.nassopoulos@gmail.com"
__status__ = "Dev"
__desc__ = "Generic utilities used across Clinical NER: safe parsing, normalization, ids, and JSON helpers."
'''

from __future__ import annotations

import json
import re
from datetime import date, datetime
from typing import Any, Iterable


## ---------------------------------------------------------------------------
## Regex patterns (kept here because they are generic project-wide constraints)
## ---------------------------------------------------------------------------

## Entity ids are generated by the pipeline and must be stable and predictable
ENTITY_ID_RE = re.compile(r"^ent_[0-9]{6}$")

## Record and patient ids must be filesystem/CSV friendly and stable
RECORD_ID_RE = re.compile(r"^[A-Za-z0-9_.:-]{1,128}$")
PATIENT_ID_RE = re.compile(r"^[A-Za-z0-9_.:-]{1,128}$")


## ---------------------------------------------------------------------------
## String and type normalization helpers
## ---------------------------------------------------------------------------

def ensure_str(value: Any) -> str:
    """
        Ensure a value is a string

        Args:
            value: Any python value

        Returns:
            A safe string representation
    """
    ## Keep empty string for None to avoid "None" appearing in CSV
    if value is None:
        return ""
    if isinstance(value, str):
        return value
    return str(value)


def ensure_str_or_none(value: Any) -> str | None:
    """
        Ensure a value is a non-empty string, otherwise return None

        Args:
            value: Any python value

        Returns:
            A stripped string or None
    """
    raw = ensure_str(value).strip()
    return raw if raw else None


## ---------------------------------------------------------------------------
## Date parsing helpers
## ---------------------------------------------------------------------------

def parse_date_to_iso(value: str | None) -> str | None:
    """
        Parse a date-like string into ISO format yyyy-mm-dd

        Supported inputs:
            - ISO: yyyy-mm-dd
            - dd/mm/yyyy
            - dd-mm-yyyy
            - yyyy/mm/dd
            - yyyy.mm.dd

        Args:
            value: Raw date string or None

        Returns:
            ISO date string or None
    """
    if value is None:
        return None

    raw = value.strip()
    if not raw:
        return None

    ## Try ISO first
    try:
        return date.fromisoformat(raw).isoformat()
    except ValueError:
        pass

    ## Try common formats
    for fmt in ("%d/%m/%Y", "%d-%m-%Y", "%Y/%m/%d", "%Y.%m.%d"):
        try:
            return datetime.strptime(raw, fmt).date().isoformat()
        except ValueError:
            continue

    ## Fallback: keep original raw string (still useful for traceability)
    return raw


## ---------------------------------------------------------------------------
## JSON helpers (safe loads, stable dumps, list extraction)
## ---------------------------------------------------------------------------

def safe_json_loads(value: str | None, default: Any = None) -> Any:
    """
        Safely load JSON from a string

        Args:
            value: JSON string or None
            default: Value returned if parsing fails

        Returns:
            Parsed JSON object or default
    """
    if default is None:
        default = []

    if value is None:
        return default

    raw = value.strip()
    if not raw:
        return default

    try:
        return json.loads(raw)
    except json.JSONDecodeError:
        return default


def json_dumps(data: Any, ensure_ascii: bool = False) -> str:
    """
        Dump data to JSON string with stable settings

        Args:
            data: Any JSON-serializable object
            ensure_ascii: Whether to escape non-ascii characters

        Returns:
            JSON string
    """
    ## separators for compactness, keep keys order stable if dict insertion order is stable
    return json.dumps(data, ensure_ascii=ensure_ascii, separators=(",", ":"))


def load_list_of_dicts_from_json(value: str | None) -> list[dict[str, Any]]:
    """
        Load a JSON string expected to represent a list of dict objects

        Args:
            value: JSON string

        Returns:
            A list of dicts, or empty list if invalid
    """
    parsed = safe_json_loads(value, default=[])
    if not isinstance(parsed, list):
        return []

    out: list[dict[str, Any]] = []
    for item in parsed:
        if isinstance(item, dict):
            out.append(item)
    return out


## ---------------------------------------------------------------------------
## ID helpers
## ---------------------------------------------------------------------------

def is_valid_entity_id(entity_id: str) -> bool:
    """
        Check if an entity id matches the canonical format

        Args:
            entity_id: Entity id string

        Returns:
            True if valid, otherwise False
    """
    return bool(ENTITY_ID_RE.match(ensure_str(entity_id).strip()))


def is_valid_record_id(record_id: str) -> bool:
    """
        Check if a record id matches the canonical format

        Args:
            record_id: Record id string

        Returns:
            True if valid, otherwise False
    """
    return bool(RECORD_ID_RE.match(ensure_str(record_id).strip()))


def is_valid_patient_id(patient_id: str) -> bool:
    """
        Check if a patient id matches the canonical format

        Args:
            patient_id: Patient id string

        Returns:
            True if valid, otherwise False
    """
    return bool(PATIENT_ID_RE.match(ensure_str(patient_id).strip()))


def ensure_unique_ids(ids: Iterable[str]) -> bool:
    """
        Check uniqueness of ids

        Args:
            ids: Iterable of ids

        Returns:
            True if all unique, otherwise False
    """
    values = [ensure_str(x) for x in ids]
    return len(values) == len(set(values))


## ---------------------------------------------------------------------------
## Export helpers (generic, avoid importing core.schema to prevent circular deps)
## ---------------------------------------------------------------------------

def records_to_jsonl(records: Iterable[Any]) -> str:
    """
        Serialize records to a JSONL string

        Supported record types:
            - dict objects
            - objects with `to_dict()` method returning a JSON-serializable dict

        Args:
            records: Iterable of records

        Returns:
            JSONL string
    """
    lines: list[str] = []

    for r in records:
        ## Convert record to dict
        if isinstance(r, dict):
            payload = r
        elif hasattr(r, "to_dict") and callable(getattr(r, "to_dict")):
            payload = r.to_dict(entities_as_list=True)  ## type: ignore[call-arg]
        else:
            ## Best effort: stringify if unknown type
            payload = {"value": ensure_str(r)}

        ## Dump one JSON per line
        lines.append(json_dumps(payload, ensure_ascii=False))

    return "\n".join(lines)
